--// CONFIGURAÃ‡Ã•ES (è¨­å®š)
_G.SilentAim = false
_G.FOV = 115 -- ã€å·²ä¿®æ”¹ã€‘åˆå§‹ FOV è¨­ç‚º 115
_G.VisibleCheck = true
_G.TeamCheck = true
_G.TeamCheckForNPCs = false
_G.Prediction = 0 
_G.UpdateRate = 0.01 
_G.TargetMode = "Players" 
_G.AimPart = "Head" 
_G.ShowTarget = true 
_G.HitChance = 100 
_G.BulletTeleport = false 
_G.ShowTargetName = true 
_G.ShowTargetType = true 
_G.ShowTargetHP = true 
_G.ShowTargetDistance = true 
_G.ShowHitChance = true 
_G.HighlightTarget = false 
_G.DebugNPCs = false 
_G.AggressiveNPCDetection = false 
_G.InstantInteract = false 

--// æ–°è¨­å®š (é«˜äº®ã€å„ªå…ˆç´šèˆ‡ç™½åå–®)
_G.TargetPriority = "TargetWeight" -- ã€å·²ä¿®æ”¹ã€‘é è¨­å•Ÿå‹•æ™ºèƒ½æ¬Šé‡æ¨¡å¼
_G.StickyAim = true 
_G.StickyUnlockDelay = 1.0 -- ã€æ–°å¢ã€‘ç›®æ¨™èº²åœ¨ç‰†å¾Œå¤šä¹…æ‰è§£é– (é è¨­ 1 ç§’)
_G.NPCHighlightColor = Color3.fromRGB(255, 50, 50)
_G.PlayerHighlightColor = Color3.fromRGB(50, 150, 255)
_G.IgnoreFriends = false -- è‡ªå‹•å¿½ç•¥ Roblox å¥½å‹
_G.CustomWhitelist = {}  -- æ‰‹å‹•ç™½åå–®åˆ—è¡¨

--// é˜²è¸¢ä¿è­·
task.spawn(function()
    for k, v in pairs(getgc(true)) do
        if pcall(function() return rawget(v, "indexInstance") end) and type(rawget(v, "indexInstance")) == "table" and (rawget(v, "indexInstance"))[1] == "kick" then
            setreadonly(v, false)
            v.tvk = {"kick", function() return game.Workspace:WaitForChild("") end}
        end
    end
end)

--// æœå‹™
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local ProximityPromptService = game:GetService("ProximityPromptService") 
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

--// ç¬é–“äº’å‹•
ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
    if _G.InstantInteract then fireproximityprompt(prompt) end
end)

--// FOV åœ“åœˆèˆ‡ UI è®Šæ•¸
local Circle = Drawing.new("Circle")
Circle.Color = Color3.fromRGB(0, 255, 0); Circle.Thickness = 2; Circle.Visible = false; Circle.Radius = _G.FOV; Circle.Transparency = 0.7; Circle.Filled = false

local TargetInfo = Drawing.new("Text")
TargetInfo.Visible = false; TargetInfo.Color = Color3.fromRGB(255, 255, 255); TargetInfo.Size = 18; TargetInfo.Font = 2; TargetInfo.Outline = true; TargetInfo.OutlineColor = Color3.fromRGB(0, 0, 0)

local TargetHighlight, HighlightConnection = nil, nil
local CurrentTarget, TargetPart, TargetInRange = nil, nil, false
local NPCCache, PlayerCache = {}, {}
local LastCacheUpdate, CacheUpdateInterval = 0, 0.5
local oldNamecall, oldIndex = nil, nil

--// éœ¸é«”è¦–é‡ä¸Ÿå¤±è¨ˆæ™‚å™¨ ã€æ–°å¢ã€‘
local TargetLostSightTime = 0 
local FriendCache = {}

--// å‡½æ•¸ï¼šå‰µå»ºèˆ‡æ›´æ–°é«˜äº®
local function CreateHighlight(target)
    if not target or not target:IsA("Model") then return nil end
    if TargetHighlight then TargetHighlight:Destroy(); TargetHighlight = nil end
    if HighlightConnection then HighlightConnection:Disconnect(); HighlightConnection = nil end
    local highlight = Instance.new("Highlight")
    highlight.Name = "SilentAimHighlight"; highlight.Adornee = target
    highlight.FillColor = Color3.fromRGB(255, 50, 50) 
    highlight.FillTransparency = 0.7; highlight.OutlineColor = Color3.fromRGB(255, 255, 255); highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop; highlight.Parent = game:GetService("CoreGui")
    HighlightConnection = target.Destroying:Connect(function() if highlight then highlight:Destroy(); TargetHighlight = nil end end)
    return highlight
end

local function UpdateHighlight()
    if not _G.HighlightTarget then
        if TargetHighlight then TargetHighlight:Destroy(); TargetHighlight = nil end
        if HighlightConnection then HighlightConnection:Disconnect(); HighlightConnection = nil end
        return
    end
    if CurrentTarget then
        if not TargetHighlight or TargetHighlight.Adornee ~= CurrentTarget then TargetHighlight = CreateHighlight(CurrentTarget) end
        if TargetHighlight then
            local isPlayer = false
            for _, data in pairs(PlayerCache) do if data.Model == CurrentTarget then isPlayer = true; break end end
            TargetHighlight.FillColor = isPlayer and _G.PlayerHighlightColor or _G.NPCHighlightColor
            TargetHighlight.FillTransparency = _G.HitChance >= 80 and (0.7 + (0.2 * (1 - (math.sin(tick() * 3) * 0.2 + 0.8)))) or 0.7
        end
    else
        if TargetHighlight then TargetHighlight:Destroy(); TargetHighlight = nil end
        if HighlightConnection then HighlightConnection:Disconnect(); HighlightConnection = nil end
    end
end

local function CleanupUIOnly()
    if Circle then Circle.Visible = false end
    if TargetInfo then TargetInfo.Visible = false; TargetInfo.Text = "" end
    if TargetHighlight then TargetHighlight:Destroy(); TargetHighlight = nil end
    if HighlightConnection then HighlightConnection:Disconnect(); HighlightConnection = nil end
    CurrentTarget, TargetPart, TargetInRange = nil, nil, false
    TargetLostSightTime = 0
    NPCCache, PlayerCache = {}, {}
end

--// NPC æ¨™ç±¤èˆ‡åµæ¸¬
local NPCTags = {"NPC", "Npc", "npc", "Enemy", "enemy", "Enemies", "enemies", "Hostile", "hostile", "Bad", "bad", "BadGuy", "badguy", "Foe", "foe", "Opponent", "opponent", "Bot", "bot", "Bots", "bots", "Mob", "mob", "Mobs", "mobs", "Monster", "monster", "Monsters", "monsters", "Zombie", "zombie", "Zombies", "zombies"}
local function IsPlayer(c) return Players:GetPlayerFromCharacter(c) ~= nil end
local function IsNPC(c)
    if not c or not c:IsA("Model") or IsPlayer(c) then return false end
    local hum, head, hrp = c:FindFirstChildOfClass("Humanoid"), c:FindFirstChild("Head"), c:FindFirstChild("HumanoidRootPart")
    if not hum or not head or not hrp or hum.Health <= 0 then return false end
    if _G.AggressiveNPCDetection then return true end
    local n = c.Name:lower()
    for _, t in pairs(NPCTags) do if n:find(t:lower(), 1, true) then return true end end
    local fols = {"NPCs", "Enemies", "Bots", "Mobs", "Targets", "Enemy", "Hostile", "Monsters", "Zombies", "Creatures", "Characters", "Spawns", "Bosses"}
    for _, f in pairs(fols) do if workspace:FindFirstChild(f) and c:IsDescendantOf(workspace[f]) then return true end end
    return false
end
local function FindNPCsInWorkspaceRecursive(p)
    local fNPCs = {}
    for _, child in pairs(p:GetChildren()) do
        if child:IsA("Model") and IsNPC(child) then table.insert(fNPCs, child) end
        if not child:IsA("BasePart") then
            for _, npc in pairs(FindNPCsInWorkspaceRecursive(child)) do table.insert(fNPCs, npc) end
        end
    end
    return fNPCs
end

--// ã€é›™é‡ç™½åå–®åˆ¤å®šé‚è¼¯ã€‘
local function IsEnemyPlayer(p)
    if not p then return true end
    if p == LocalPlayer then return false end

    -- 1. æª¢æŸ¥æ‰‹å‹•ç™½åå–®
    local pName = string.lower(p.Name)
    local pDisplay = string.lower(p.DisplayName)
    for _, whitelistName in ipairs(_G.CustomWhitelist) do
        local safeName = string.lower(whitelistName)
        if string.find(pName, safeName, 1, true) or string.find(pDisplay, safeName, 1, true) then
            return false 
        end
    end

    -- 2. æª¢æŸ¥è‡ªå‹• Roblox å¥½å‹
    if _G.IgnoreFriends then
        if FriendCache[p.UserId] == nil then
            task.spawn(function() pcall(function() FriendCache[p.UserId] = LocalPlayer:IsFriendsWith(p.UserId) end) end)
        elseif FriendCache[p.UserId] == true then
            return false 
        end
    end

    -- 3. æª¢æŸ¥ç³»çµ±éšŠä¼
    if _G.TeamCheck then 
        if LocalPlayer.Team and p.Team and LocalPlayer.Team == p.Team then return false end 
    end
    return true
end

local function IsEnemyNPC(m)
    if not _G.TeamCheckForNPCs then return true end
    local tv = m:FindFirstChild("Team")
    if tv and tv:IsA("StringValue") and tv.Value ~= (LocalPlayer.Team and LocalPlayer.Team.Name or "") then return true end
    local ie = m:FindFirstChild("IsEnemy")
    if ie and ie:IsA("BoolValue") and ie.Value then return true end
    return true
end

local function GetTargetPart(c)
    if _G.AimPart == "Head" then return c:FindFirstChild("Head")
    elseif _G.AimPart == "Torso" then return c:FindFirstChild("UpperTorso") or c:FindFirstChild("Torso") or c:FindFirstChild("HumanoidRootPart")
    elseif _G.AimPart == "Random" then
        local p = {c:FindFirstChild("Head"), c:FindFirstChild("UpperTorso"), c:FindFirstChild("Torso"), c:FindFirstChild("HumanoidRootPart")}
        for _, v in pairs(p) do if v then return v end end
    elseif _G.AimPart == "Both" then
        local head = c:FindFirstChild("Head")
        local torso = c:FindFirstChild("UpperTorso") or c:FindFirstChild("Torso") or c:FindFirstChild("HumanoidRootPart")
        if head and torso then return tick() % 1 > 0.5 and head or torso elseif head then return head elseif torso then return torso end
    end
    return c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("Head")
end

local function UpdateCaches()
    if tick() - LastCacheUpdate < CacheUpdateInterval then return end
    LastCacheUpdate = tick()
    local tNPC, tPlayer, allM = {}, {}, {}
    for _, m in pairs(workspace:GetChildren()) do if m:IsA("Model") and m ~= LocalPlayer.Character then table.insert(allM, m) end end
    local fols = {"NPCs", "Enemies", "Bots", "Mobs", "Targets", "Characters", "Spawns", "Monsters", "Zombies", "Enemy"}
    for _, fn in pairs(fols) do
        if workspace:FindFirstChild(fn) then for _, npc in pairs(FindNPCsInWorkspaceRecursive(workspace[fn])) do table.insert(allM, npc) end end
    end
    if _G.AggressiveNPCDetection then
        local c = 0
        for _, d in pairs(workspace:GetDescendants()) do
            if d:IsA("Model") and d ~= LocalPlayer.Character then table.insert(allM, d); c = c + 1; if c % 150 == 0 then task.wait() end end
        end
    end
    local pc = 0
    for _, m in pairs(allM) do
        pc = pc + 1; if pc % 200 == 0 then task.wait() end
        local hrp, hum = m:FindFirstChild("HumanoidRootPart"), m:FindFirstChildOfClass("Humanoid")
        if hrp and hum and hum.Health > 0 then
            if IsPlayer(m) then tPlayer[m] = {Model = m, HRP = hrp, Humanoid = hum, Player = Players:GetPlayerFromCharacter(m)}
            elseif IsNPC(m) then tNPC[m] = {Model = m, HRP = hrp, Humanoid = hum} end
        end
    end
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character then
            local hrp, hum = p.Character:FindFirstChild("HumanoidRootPart"), p.Character:FindFirstChildOfClass("Humanoid")
            if hrp and hum and hum.Health > 0 then tPlayer[p.Character] = {Model = p.Character, HRP = hrp, Humanoid = hum, Player = p} end
        end
    end
    NPCCache, PlayerCache = tNPC, tPlayer
end

--// ã€é‡å¯«ï¼šéœ¸é«”è§£é–æ©Ÿåˆ¶ã€‘é©—è­‰ç•¶å‰ç›®æ¨™
local function ValidateCurrentTarget()
    if not CurrentTarget or not TargetPart then return false end
    local humanoid = CurrentTarget:FindFirstChildOfClass("Humanoid")
    local hrp = CurrentTarget:FindFirstChild("HumanoidRootPart")
    if not humanoid or humanoid.Health <= 0 or not hrp then return false end
    
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local targetPos = TargetPart.Position
    local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
    
    if not onScreen then return false end
    
    local screenPoint = Vector2.new(screenPos.X, screenPos.Y)
    local dist = (screenPoint - screenCenter).Magnitude
    local allowedFOV = _G.StickyAim and (_G.FOV * 1.5) or _G.FOV
    if dist > allowedFOV then return false end
    
    if _G.VisibleCheck then
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
        raycastParams.IgnoreWater = true
        
        local origin = Camera.CFrame.Position
        local direction = (targetPos - origin).Unit * (targetPos - origin).Magnitude
        local ray = workspace:Raycast(origin, direction, raycastParams)
        
        local isVisible = (not ray) or (ray.Instance:IsDescendantOf(CurrentTarget))
        
        if isVisible then
            TargetLostSightTime = 0 
        else
            if _G.StickyAim then
                if TargetLostSightTime == 0 then
                    TargetLostSightTime = tick() 
                elseif (tick() - TargetLostSightTime) > _G.StickyUnlockDelay then
                    TargetLostSightTime = 0
                    return false
                end
            else
                return false
            end
        end
    end
    return true
end

--// ã€æ ¸å¿ƒä¿®æ”¹ã€‘æœå°‹ç›®æ¨™ (æ–°å¢ TargetWeight é‚è¼¯)
local function GetTarget()
    if not LocalPlayer.Character then TargetInRange = false; TargetPart = nil; return nil end
    UpdateCaches()

    if _G.StickyAim and CurrentTarget then
        if ValidateCurrentTarget() then 
            TargetInRange = true
            return CurrentTarget 
        else 
            CurrentTarget = nil 
            TargetPart = nil 
            TargetLostSightTime = 0 
        end
    end

    local bestScore = _G.TargetPriority == "TargetWeight" and -math.huge or math.huge
    local closestPart, closestTarget = nil, nil
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local localChar = LocalPlayer.Character
    local localRoot = localChar:FindFirstChild("HumanoidRootPart")
    TargetInRange = false; TargetPart = nil
    if not localRoot then return nil end

    local function ProcessTarget(data, isPlayer)
        local hrp, humanoid = data.HRP, data.Humanoid
        if hrp and humanoid and humanoid.Health > 0 then
            if isPlayer then if not IsEnemyPlayer(data.Player) then return end
            else if not IsEnemyNPC(data.Model) then return end end

            local targetPart = GetTargetPart(data.Model)
            if not targetPart then targetPart = hrp end
            local targetPos = targetPart.Position

            if hrp.Velocity.Magnitude > 1 and _G.Prediction > 0 then targetPos = targetPos + (hrp.Velocity * _G.Prediction) end
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)

            if onScreen then
                local screenPoint = Vector2.new(screenPos.X, screenPos.Y)
                local distFromCenter = (screenPoint - screenCenter).Magnitude
                if distFromCenter <= _G.FOV then
                    local isVisible = true
                    if _G.VisibleCheck then
                        local raycastParams = RaycastParams.new(); raycastParams.FilterType = Enum.RaycastFilterType.Exclude; raycastParams.FilterDescendantsInstances = {localChar, Camera}; raycastParams.IgnoreWater = true
                        local origin = Camera.CFrame.Position; local direction = (targetPos - origin).Unit * (targetPos - origin).Magnitude
                        local ray = workspace:Raycast(origin, direction, raycastParams)
                        if ray and not ray.Instance:IsDescendantOf(data.Model) then isVisible = false end
                    end

                    if isVisible or not _G.VisibleCheck then
                        TargetInRange = true
                        local dist3D = (targetPos - localRoot.Position).Magnitude
                        
                        -- ==========================================
                        -- ç›®æ¨™æ¬Šé‡ç³»çµ± (Target Weight)
                        -- ==========================================
                        if _G.TargetPriority == "TargetWeight" then
                            local score = 0
                            score = score + (2000 / math.max(distFromCenter, 1))
                            score = score + (1000 / math.max(dist3D, 1))
                            score = score + (500 / math.max(humanoid.Health, 1))
                            if isPlayer then score = score + 5000 end

                            if score > bestScore then
                                bestScore = score
                                closestPart = targetPart
                                closestTarget = data.Model
                            end
                        else
                            local currentScore = 0
                            if _G.TargetPriority == "Crosshair" then currentScore = distFromCenter
                            elseif _G.TargetPriority == "Distance" then currentScore = dist3D
                            elseif _G.TargetPriority == "LowestHP" then currentScore = humanoid.Health
                            else currentScore = distFromCenter end

                            if currentScore < bestScore then 
                                bestScore = currentScore
                                closestPart = targetPart
                                closestTarget = data.Model 
                            end
                        end
                    end
                end
            end
        end
    end

    if _G.TargetMode == "NPCs" or _G.TargetMode == "Both" then for _, data in pairs(NPCCache) do ProcessTarget(data, false) end end
    if _G.TargetMode == "Players" or _G.TargetMode == "Both" then for _, data in pairs(PlayerCache) do ProcessTarget(data, true) end end

    if closestTarget then
        TargetLostSightTime = 0 -- é–å®šæ–°ç›®æ¨™æ™‚ï¼Œç¢ºä¿è¨ˆæ™‚å™¨æ­¸é›¶
    end
    
    TargetPart = closestPart
    return closestTarget
end

task.spawn(function()
    while true do
        task.wait(_G.UpdateRate)
        if _G.SilentAim then CurrentTarget = GetTarget()
        else CurrentTarget = nil; TargetInRange = false; TargetPart = nil; TargetLostSightTime = 0 end
    end
end)

local function ShouldHit()
    if _G.HitChance >= 100 then return true end
    if _G.HitChance <= 0 then return false end
    return math.random(1, 100) <= _G.HitChance
end

local function CalculateHitChanceDisplay()
    if not CurrentTarget or not TargetPart then return 0 end
    local baseChance = _G.HitChance
    local distanceFactor = 1.0; local fovFactor = 1.0
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local distance = (TargetPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
        if distance < 50 then distanceFactor = 1.1 elseif distance > 200 then distanceFactor = 0.8 end
    end
    if _G.FOV < 100 then fovFactor = 1.15 elseif _G.FOV > 250 then fovFactor = 0.9 end
    local finalChance = math.clamp((baseChance * distanceFactor * fovFactor) + math.random(-5, 5), 1, 100)
    return math.floor(finalChance)
end

local function UpdateTargetInfo()
    if not _G.ShowTarget or not TargetInfo or not _G.SilentAim then
        TargetInfo.Visible = false; TargetInfo.Text = ""; return
    end
    local shouldShowHitChance = _G.ShowHitChance and _G.HitChance > 0
    if CurrentTarget and TargetPart then
        local screenPos, onScreen = Camera:WorldToViewportPoint(TargetPart.Position)
        if onScreen then
            TargetInfo.Visible = true; TargetInfo.Position = Vector2.new(screenPos.X, screenPos.Y + 20)
            local infoLines = {}
            if _G.ShowTargetName then
                local targetName = CurrentTarget.Name; local targetType = "NPC"
                for _, data in pairs(PlayerCache) do if data.Model == CurrentTarget then targetType = "ç©å®¶"; targetName = data.Player.Name; break end end
                if _G.ShowTargetType then table.insert(infoLines, string.format("[%s] %s", targetType, targetName)) else table.insert(infoLines, targetName) end
            end
            if _G.ShowTargetHP then
                local humanoid = CurrentTarget:FindFirstChildOfClass("Humanoid")
                if humanoid then table.insert(infoLines, string.format("HP: %.0f/%.0f", humanoid.Health, humanoid.MaxHealth)) end
            end
            if _G.ShowTargetDistance then
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local distance = string.format("%.1f", (TargetPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude)
                    table.insert(infoLines, string.format("è·é›¢: %s studs", distance))
                end
            end
            
            -- ã€æ–°å¢ã€‘åœ¨ UI ä¸Šé¡¯ç¤ºå³å°‡ä¸Ÿå¤±è¦–é‡çš„å€’æ•¸ç‹€æ…‹
            if TargetLostSightTime > 0 then
                local timeLeft = _G.StickyUnlockDelay - (tick() - TargetLostSightTime)
                if timeLeft > 0 then
                    table.insert(infoLines, string.format("âš ï¸ ç›®æ¨™ä¸Ÿå¤±: %.1fç§’", timeLeft))
                end
            end

            if shouldShowHitChance then table.insert(infoLines, string.format("æ©Ÿç‡: %d%%", CalculateHitChanceDisplay())) end
            TargetInfo.Text = #infoLines > 0 and table.concat(infoLines, "\n") or "å·²é–å®šç›®æ¨™"
        else TargetInfo.Visible = false; TargetInfo.Text = "" end
    else TargetInfo.Visible = false; TargetInfo.Text = "" end
end

--// HOOKS
if not oldNamecall then
    oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        if not _G.SilentAim or not TargetPart or not CurrentTarget then return oldNamecall(self, ...) end
        local method = getnamecallmethod(); local args = {...}
        if (method == "FireServer" or method == "InvokeServer") and typeof(self) == "Instance" then
            local selfName = self.Name:lower()
            if string.find(selfName, "fire") or string.find(selfName, "hit") or string.find(selfName, "attack") or string.find(selfName, "damage") then
                if not ShouldHit() then return oldNamecall(self, ...) end
                local newArgs = {}; local modified = false
                for i, arg in pairs(args) do
                    if typeof(arg) == "Vector3" then newArgs[i] = TargetPart.Position; modified = true
                    elseif typeof(arg) == "CFrame" then newArgs[i] = CFrame.new(TargetPart.Position); modified = true
                    elseif typeof(arg) == "Ray" then newArgs[i] = Ray.new(arg.Origin, (TargetPart.Position - arg.Origin).Unit * 100); modified = true
                    else newArgs[i] = arg end
                end
                if modified then return oldNamecall(self, unpack(newArgs)) end
            end
        end
        if method == "Raycast" and self == workspace then
            local origin = args[1]; local direction = args[2]
            if origin and TargetPart then
                if not ShouldHit() then return oldNamecall(self, ...) end
                local newDir = (TargetPart.Position - origin).Unit * direction.Magnitude
                return oldNamecall(self, origin, newDir, args[3], args[4])
            end
        end
        return oldNamecall(self, ...)
    end)
end

if not oldIndex then
    oldIndex = hookmetamethod(game, "__index", function(self, key)
        if self == Mouse and _G.SilentAim and TargetPart then
            local keyLower = string.lower(key)
            if keyLower == "hit" then
                if not ShouldHit() then return oldIndex(self, key) end
                return CFrame.new(TargetPart.Position)
            elseif keyLower == "target" then return TargetPart end
        end
        return oldIndex(self, key)
    end)
end

RunService.RenderStepped:Connect(function()
    Circle.Visible = _G.SilentAim
    if _G.SilentAim then
        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        Circle.Position = screenCenter
        Circle.Radius = _G.FOV

        if CurrentTarget then
            local isPlayerTarget = false
            for _, data in pairs(PlayerCache) do if data.Model == CurrentTarget then isPlayerTarget = true; break end end
            Circle.Color = isPlayerTarget and Color3.fromRGB(0, 150, 255) or Color3.fromRGB(0, 255, 0)
        else
            Circle.Color = TargetInRange and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 50, 0)
        end
    else Circle.Visible = false end

    UpdateTargetInfo()
    UpdateHighlight()
end)

--// ==================================================
--// ç²å–ä¼ºæœå™¨å…§æ‰€æœ‰ç©å®¶åç¨±çš„å‡½æ•¸ (ä¾›é¸å–®ä½¿ç”¨)
--// ==================================================
local function GetServerPlayerNames()
    local names = {}
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            table.insert(names, p.Name)
        end
    end
    if #names == 0 then table.insert(names, "ç„¡å…¶ä»–ç©å®¶") end
    return names
end

--// ==================================================
--// MANO GUSTAVO UI LIBRARY (å®Œæ•´æ¢å¾©ç‰ˆ)
--// ==================================================
local Library = loadstring(game:HttpGet(
    "https://raw.githubusercontent.com/Mano-Gustavo/Mano-Gustavo-Library/refs/heads/main/library.lua"
))()

local Window = Library:CreateWindow({
    Title = "ğŸ¯ éœé»˜ç„æº– (æ™ºèƒ½æ¬Šé‡ + éœ¸é«”å„ªåŒ–ç‰ˆ)",
    Author = "Silent Aim Universal",
    Keybind = Enum.KeyCode.RightControl
})

local TabMain = Window:CreateTab("ä¸»è¦è¨­å®š")
local TabPriority = Window:CreateTab("å„ªå…ˆç´šåˆ¥")
local TabConfig = Window:CreateTab("è©³ç´°è¨­å®š")
local TabAim = Window:CreateTab("ç„æº–è¦–è¦º")
local TabTeam = Window:CreateTab("éšŠä¼ / ç™½åå–®") 
local TabExtra = Window:CreateTab("é¡å¤–åŠŸèƒ½")
local TabNPC = Window:CreateTab("NPC æ§åˆ¶")
local TabInfo = Window:CreateTab("è³‡è¨Šèˆ‡ç‹€æ…‹")

TabMain:CreateLabel("=== ä¸»è¦æ§åˆ¶é … ===")
TabMain:CreateToggle("å•Ÿå‹•éœé»˜ç„æº– (Silent Aim)", function(Value)
    _G.SilentAim = Value
    if Value then
        LastCacheUpdate = 0; UpdateCaches()
        Library:Notification({Title = "ğŸ¯ éœé»˜ç„æº–", Text = "å·²å•Ÿç”¨", Duration = 1.5, Type = "Success"})
    else
        if TargetHighlight then TargetHighlight:Destroy(); TargetHighlight = nil end
        Library:Notification({Title = "ğŸ¯ éœé»˜ç„æº–", Text = "å·²åœç”¨", Duration = 1.5, Type = "Error"})
    end
end, false)
-- ã€å·²ä¿®æ”¹ã€‘é è¨­ 115
TabMain:CreateSlider("ç¯„åœå¤§å° (FOV)", 50, 300, 115, function(Value) _G.FOV = math.floor(Value); Circle.Radius = _G.FOV end)
TabMain:CreateSlider("é åˆ¤å¼·åº¦ (PrediÃ§Ã£o)", 0, 0.5, 0, function(Value) _G.Prediction = tonumber(string.format("%.3f", Value)) end) 
TabMain:CreateSlider("å‘½ä¸­æ©Ÿç‡ (Hit Chance)", 0, 100, 100, function(Value) _G.HitChance = math.floor(Value) end)
TabMain:CreateSlider("æ›´æ–°é »ç‡ (Taxa de AtualizaÃ§Ã£o)", 0, 0.5, 0.01, function(Value) _G.UpdateRate = tonumber(string.format("%.3f", Value)) end) 

TabPriority:CreateLabel("=== ç›®æ¨™é–å®šé‚è¼¯ ===")
-- ã€å·²ä¿®æ”¹ã€‘æ–°å¢ TargetWeightï¼Œä¸¦é è¨­
TabPriority:CreateDropdown("å„ªå…ˆæ¨¡å¼", {"TargetWeight", "Crosshair", "Distance", "LowestHP"}, function(Value)
    _G.TargetPriority = Value; CurrentTarget = nil; TargetLostSightTime = 0 
    Library:Notification({Title = "æ¨¡å¼å·²è®Šæ›´", Text = "ç•¶å‰å„ªå…ˆ: " .. Value, Duration = 2})
end)
TabPriority:CreateToggle("é»æ€§é–å®š (Sticky Aim)", function(Value) _G.StickyAim = Value end, true)
-- ã€æ–°å¢ã€‘è§£é–å»¶é²æ»‘æ¡¿
TabPriority:CreateSlider("éœ¸é«”è§£é–å»¶é² (ç§’)", 0.1, 3.0, 1.0, function(Value) 
    _G.StickyUnlockDelay = tonumber(string.format("%.1f", Value)) 
end)
TabPriority:CreateLabel("----------------")
TabPriority:CreateLabel("â€¢ TargetWeight (æ¬Šé‡): ç¶œåˆåˆ¤æ–· è‡ªå‹•é¸å–æœ€é«˜å¨è„…ç›®æ¨™")
TabPriority:CreateLabel("â€¢ Crosshair (æº–æ˜Ÿ): é–å®šæœ€é è¿‘ç•«é¢ä¸­å¿ƒçš„ç›®æ¨™")
TabPriority:CreateLabel("â€¢ Distance (è·é›¢): é–å®šéŠæˆ²å…§è·é›¢ä½ æœ€è¿‘çš„ç›®æ¨™")
TabPriority:CreateLabel("â€¢ LowestHP (è¡€é‡): é–å®šè¡€é‡æœ€å°‘çš„ç›®æ¨™")
TabPriority:CreateLabel("â€¢ é»æ€§é–å®š: å®¹è¨±ç›®æ¨™çŸ­æš«èº²åœ¨éšœç¤™ç‰©å¾Œè€Œä¸æ‰é–å®šã€‚")

TabConfig:CreateLabel("=== ä¸€èˆ¬è¨­å®š ===")
TabConfig:CreateDropdown("ç„æº–å°è±¡", {"Players", "NPCs", "Both"}, function(Value) _G.TargetMode = Value end) 
TabConfig:CreateDropdown("èº«é«”éƒ¨ä½", {"Head", "Torso", "Both", "Random"}, function(Value) _G.AimPart = Value end)
TabConfig:CreateToggle("ç‰†å£æª¢æŸ¥ (Wall Check)", function(Value) _G.VisibleCheck = Value end, true)
TabConfig:CreateToggle("å­å½ˆå‚³é€ (Bullet Teleport)", function(Value) _G.BulletTeleport = Value end, false)
TabConfig:CreateToggle("é¡¯ç¤ºç›®æ¨™å¤–æ¡†", function(Value) _G.ShowTarget = Value end, true)

TabAim:CreateLabel("=== ç„æº–é¡è¨­å®š ===")
TabAim:CreateColorPicker("FOV åœ“åœˆé¡è‰²", Color3.fromRGB(0, 255, 0), function(Color) Circle.Color = Color end)

TabTeam:CreateLabel("=== ç³»çµ±éšŠä¼åˆ¤å®š ===")
TabTeam:CreateToggle("æª¢æŸ¥éšŠå‹ (ç©å®¶)", function(Value) _G.TeamCheck = Value end, true)
TabTeam:CreateToggle("æª¢æŸ¥éšŠå‹ (NPC)", function(Value) _G.TeamCheckForNPCs = Value end, false)

TabTeam:CreateLabel("=== ğŸ›¡ï¸ ç©å®¶ç™½åå–® (å…æ­»é‡‘ç‰Œ) ===")
TabTeam:CreateToggle("è‡ªå‹•å¿½ç•¥ Roblox ç³»çµ±å¥½å‹", function(Value) 
    _G.IgnoreFriends = Value 
    if Value then Library:Notification({Title = "ç™½åå–®", Text = "å°‡è‡ªå‹•é¿é–‹ Roblox ç³»çµ±å¥½å‹", Duration = 2}) end
end, false)

TabTeam:CreateLabel("ğŸ‘‡ å¾ç•¶å‰ä¼ºæœå™¨ä¸­é¸æ“‡ç©å®¶ğŸ‘‡")

local PlayerDropdown
PlayerDropdown = TabTeam:CreateDropdown("é¸æ“‡ç©å®¶åŠ å…¥ç™½åå–®", GetServerPlayerNames(), function(Value)
    if Value and Value ~= "" and Value ~= "ç„¡å…¶ä»–ç©å®¶" then
        local exists = false
        for _, v in ipairs(_G.CustomWhitelist) do
            if v == Value then exists = true; break end
        end

        if not exists then
            table.insert(_G.CustomWhitelist, Value)
            Library:Notification({Title = "ğŸ›¡ï¸ ç™½åå–®å·²æ›´æ–°", Text = "å·²æˆåŠŸåŠ å…¥: " .. Value, Duration = 3, Type = "Success"})
        else
            Library:Notification({Title = "ğŸ›¡ï¸ ç™½åå–®", Text = Value .. " å·²ç¶“åœ¨ç™½åå–®ä¸­äº†ï¼", Duration = 2, Type = "Warning"})
        end
    end
end)

TabTeam:CreateButton("ğŸ”„ åˆ·æ–°ä¼ºæœå™¨ç©å®¶åˆ—è¡¨", function()
    pcall(function()
        if PlayerDropdown and PlayerDropdown.Refresh then
            PlayerDropdown:Refresh(GetServerPlayerNames())
            Library:Notification({Title = "ğŸ”„ åˆ·æ–°æˆåŠŸ", Text = "ç©å®¶åˆ—è¡¨å·²æ›´æ–°ï¼", Duration = 2})
        elseif PlayerDropdown and PlayerDropdown.SetOptions then
            PlayerDropdown:SetOptions(GetServerPlayerNames())
            Library:Notification({Title = "ğŸ”„ åˆ·æ–°æˆåŠŸ", Text = "ç©å®¶åˆ—è¡¨å·²æ›´æ–°ï¼", Duration = 2})
        else
            Library:Notification({Title = "æç¤º", Text = "æ­¤ UI åº«å¯èƒ½ä¸æ”¯æ´å‹•æ…‹åˆ·æ–°ï¼Œè«‹é‡æ–°åŸ·è¡Œè…³æœ¬ã€‚", Duration = 3, Type = "Error"})
        end
    end)
end)

TabTeam:CreateButton("ğŸ—‘ï¸ æ¸…ç©ºæ‰‹å‹•ç™½åå–®", function()
    _G.CustomWhitelist = {}
    Library:Notification({Title = "ç™½åå–®", Text = "æ‰‹å‹•ç™½åå–®å·²å…¨éƒ¨æ¸…ç©ºï¼", Duration = 2, Type = "Error"})
end)

TabExtra:CreateLabel("=== é¡å¤–é¡¯ç¤ºè¨­å®š ===")
TabExtra:CreateToggle("ç›®æ¨™é«˜äº®é¡¯ç¤º (Highlight)", function(Value) _G.HighlightTarget = Value end, false)
TabExtra:CreateColorPicker("NPC é«˜äº®é¡è‰²", _G.NPCHighlightColor, function(Color) _G.NPCHighlightColor = Color end)
TabExtra:CreateColorPicker("ç©å®¶é«˜äº®é¡è‰²", _G.PlayerHighlightColor, function(Color) _G.PlayerHighlightColor = Color end)
TabExtra:CreateTextBox("å¿«å–åˆ·æ–°é–“éš” (ç§’)", "0.5", function(Text) local num = tonumber(Text); if num and num >= 0 then CacheUpdateInterval = num end end)

TabExtra:CreateLabel("=== å¯¦ç”¨åŠŸèƒ½ ===")
TabExtra:CreateToggle("ç¬é–“äº’å‹• (Instant Interact)", function(Value) _G.InstantInteract = Value end, false)

TabNPC:CreateLabel("=== æˆ°è¡“ç›®æ¨™æƒæ ===")
TabNPC:CreateToggle("ğŸ”¥ æ·±åº¦é§­å…¥æƒæ (ç„¡æ­»è§’åµæ¸¬)", function(Value)
    _G.AggressiveNPCDetection = Value; LastCacheUpdate = 0; UpdateCaches()
end, false)
TabNPC:CreateToggle("ğŸ“¡ æ””æˆªåº•å±¤æ•¸æ“š (é–‹ç™¼è€…æ¨¡å¼)", function(Value) _G.DebugNPCs = Value end, false)
TabNPC:CreateButton("âš¡ ç¬é–“é‡è¼‰ç›®æ¨™é›·é”", function() LastCacheUpdate = 0; UpdateCaches() end)
TabNPC:CreateButton("ğŸ“Š å•Ÿå‹•ç”Ÿå‘½æ¢æ¸¬å„€ (å›å ±çµç‰©æ•¸)", function()
    local npcCount = 0; for _ in pairs(NPCCache) do npcCount = npcCount + 1 end
    Library:Notification({Title = "ğŸ“Š æˆ°è¡“é›·é”", Text = string.format("ç•¶å‰å€åŸŸå·²é–å®šçµç‰©: %d å", npcCount), Duration = 3})
end)

TabInfo:CreateLabel("=== è³‡è¨Šä»‹é¢æ§åˆ¶ ===")
TabInfo:CreateToggle("é¡¯ç¤º åç¨±/é¡å‹", function(Value) _G.ShowTargetName = Value; if _G.SilentAim then UpdateTargetInfo() end end, true)
TabInfo:CreateToggle("é¡¯ç¤º è¡€é‡ (HP)", function(Value) _G.ShowTargetHP = Value; if _G.SilentAim then UpdateTargetInfo() end end, true)
TabInfo:CreateToggle("é¡¯ç¤º è·é›¢", function(Value) _G.ShowTargetDistance = Value; if _G.SilentAim then UpdateTargetInfo() end end, true)
TabInfo:CreateToggle("é¡¯ç¤º å‘½ä¸­æ©Ÿç‡", function(Value) _G.ShowHitChance = Value; if _G.SilentAim then UpdateTargetInfo() end end, true)

TabInfo:CreateLabel("âœ… å·²ä¿®å¾©ç‰†å¾Œæ­»é–å•é¡Œï¼Œæ–°å¢è¨ˆæ™‚è§£é™¤æ©Ÿåˆ¶")
TabInfo:CreateLabel("âœ… å·²å•Ÿç”¨ TargetWeight æ™ºèƒ½é–å®š")
TabInfo:CreateButton("æ¸…é™¤ç•«é¢ UI", function() CleanupUIOnly() end)

Library:Notification({
    Title = "ğŸ¯ ç³»çµ±å·²å°±ç·’",
    Text = "éœ¸é«”è¨ˆæ™‚è§£é–ç³»çµ±å·²ä¸Šç·šï¼",
    Duration = 4,
    Type = "Success"
})

game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then CleanupUIOnly() end
end)
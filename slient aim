--// CONFIGURAÃ‡Ã•ES (è¨­å®š)
_G.SilentAim = false
_G.FOV = 150
_G.VisibleCheck = true
_G.TeamCheck = true
_G.TeamCheckForNPCs = false
_G.Prediction = 0 -- é‡å° The Border è¨­ç‚º 0 (ç„¡é åˆ¤ï¼Œå³æ™‚å‘½ä¸­æœ€æº–)
_G.UpdateRate = 0.01 -- æ¥µè‡´åˆ·æ–°ç‡
_G.TargetMode = "Players" -- é è¨­åªé–å®šç©å®¶ï¼Œå¤§å¹…é™ä½å¡é “
_G.AimPart = "Head" -- "Head", "Torso", "Both", "Random"
_G.ShowTarget = true -- é¡¯ç¤ºç›®æ¨™è³‡è¨Š
_G.HitChance = 100 -- å‘½ä¸­æ©Ÿç‡ (1-100%)
_G.BulletTeleport = false -- å­å½ˆå‚³é€åˆ°ç›®æ¨™
_G.ShowTargetName = true -- é¡¯ç¤ºç›®æ¨™åç¨±
_G.ShowTargetType = true -- é¡¯ç¤ºé¡å‹ (NPC/ç©å®¶)
_G.ShowTargetHP = true -- é¡¯ç¤ºç›®æ¨™è¡€é‡
_G.ShowTargetDistance = true -- é¡¯ç¤ºè·é›¢
_G.ShowHitChance = true -- é¡¯ç¤ºå‘½ä¸­æ©Ÿç‡
_G.HighlightTarget = false -- é«˜äº®ç›®æ¨™
_G.DebugNPCs = false -- åœ¨æ§åˆ¶å°é¡¯ç¤ºåµæ¸¬åˆ°çš„ NPC
_G.AggressiveNPCDetection = false -- æ¿€é€²æ¨¡å¼ï¼šé è¨­é—œé–‰
_G.InstantInteract = false -- [æ–°å¢] ç¬é–“äº’å‹•é–‹é—œ

--// æ–°è¨­å®š (å„ªå…ˆç´š)
_G.TargetPriority = "Crosshair" -- é è¨­ç‚ºæº–æ˜Ÿå„ªå…ˆï¼Œé©åˆäººç¾¤ä¸­é»å
_G.StickyAim = true -- è‹¥ç‚º trueï¼Œé–å®šç›®æ¨™ç›´åˆ°æ­»äº¡æˆ–é›¢é–‹ FOV (é˜²æ­¢æŠ–å‹•)

--// é˜²è¸¢ä¿è­· (è‡ªå‹•å•Ÿç”¨)
task.spawn(function()
    for k, v in pairs(getgc(true)) do
        if pcall(function()
            return rawget(v, "indexInstance")
        end) and type(rawget(v, "indexInstance")) == "table" and (rawget(v, "indexInstance"))[1] == "kick" then
            setreadonly(v, false)
            v.tvk = {
                "kick",
                function()
                    return game.Workspace:WaitForChild("")
                end
            }
        end
    end
end)

--// æœå‹™
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local ProximityPromptService = game:GetService("ProximityPromptService") -- [æ–°å¢] äº’å‹•æœå‹™
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

--// ç¬é–“äº’å‹•é‚è¼¯ (Instant Interact)
ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt, player)
    if _G.InstantInteract then
        fireproximityprompt(prompt)
    end
end)

--// FOV åœ“åœˆ
local Circle = Drawing.new("Circle")
Circle.Color = Color3.fromRGB(0, 255, 0)
Circle.Thickness = 2
Circle.Visible = false
Circle.Radius = _G.FOV
Circle.Transparency = 0.7
Circle.Filled = false

--// ç›®æ¨™è³‡è¨Š (æ–‡å­—)
local TargetInfo = Drawing.new("Text")
TargetInfo.Visible = false
TargetInfo.Color = Color3.fromRGB(255, 255, 255)
TargetInfo.Size = 18
TargetInfo.Font = 2
TargetInfo.Outline = true
TargetInfo.OutlineColor = Color3.fromRGB(0, 0, 0)
TargetInfo.Text = ""

--// é«˜äº®ç›®æ¨™
local TargetHighlight = nil
local HighlightConnection = nil

--// è®Šæ•¸
local CurrentTarget = nil
local TargetPart = nil
local TargetInRange = false
local NPCCache = {}
local PlayerCache = {}
local LastCacheUpdate = 0
local CacheUpdateInterval = 0.5 -- ç¸®çŸ­å¿«å–é–“éš”

--// HOOKS è®Šæ•¸
local oldNamecall = nil
local oldIndex = nil

--// å‡½æ•¸ï¼šå‰µå»ºé«˜äº®
local function CreateHighlight(target)
    if not target or not target:IsA("Model") then return nil end
    if TargetHighlight then TargetHighlight:Destroy(); TargetHighlight = nil end
    if HighlightConnection then HighlightConnection:Disconnect(); HighlightConnection = nil end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "SilentAimHighlight"
    highlight.Adornee = target
    highlight.FillColor = Color3.fromRGB(255, 50, 50)
    highlight.FillTransparency = 0.7
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = game:GetService("CoreGui")
    
    HighlightConnection = target.Destroying:Connect(function()
        if highlight then highlight:Destroy(); TargetHighlight = nil end
    end)
    return highlight
end

--// å‡½æ•¸ï¼šæ›´æ–°é«˜äº®
local function UpdateHighlight()
    if not _G.HighlightTarget then
        if TargetHighlight then TargetHighlight:Destroy(); TargetHighlight = nil end
        if HighlightConnection then HighlightConnection:Disconnect(); HighlightConnection = nil end
        return
    end
    if CurrentTarget then
        if not TargetHighlight or TargetHighlight.Adornee ~= CurrentTarget then
            TargetHighlight = CreateHighlight(CurrentTarget)
        end
        if TargetHighlight then
            local isPlayer = false
            for _, data in pairs(PlayerCache) do if data.Model == CurrentTarget then isPlayer = true; break end end
            TargetHighlight.FillColor = isPlayer and Color3.fromRGB(50, 150, 255) or Color3.fromRGB(255, 50, 50)
            if _G.HitChance >= 80 then
                local pulse = math.sin(tick() * 3) * 0.2 + 0.8
                TargetHighlight.FillTransparency = 0.7 + (0.2 * (1 - pulse))
            else
                TargetHighlight.FillTransparency = 0.7
            end
        end
    else
        if TargetHighlight then TargetHighlight:Destroy(); TargetHighlight = nil end
        if HighlightConnection then HighlightConnection:Disconnect(); HighlightConnection = nil end
    end
end

--// å‡½æ•¸ï¼šåƒ…æ¸…ç† UI
local function CleanupUIOnly()
    if Circle then Circle.Visible = false end
    if TargetInfo then TargetInfo.Visible = false; TargetInfo.Text = "" end
    if TargetHighlight then TargetHighlight:Destroy(); TargetHighlight = nil end
    if HighlightConnection then HighlightConnection:Disconnect(); HighlightConnection = nil end
    CurrentTarget = nil; TargetPart = nil; TargetInRange = false
    NPCCache = {}; PlayerCache = {}
end

--// NPC æ¨™ç±¤åˆ—è¡¨
local NPCTags = {
    "NPC", "Npc", "npc", "Enemy", "enemy", "Enemies", "enemies",
    "Hostile", "hostile", "Bad", "bad", "BadGuy", "badguy",
    "Foe", "foe", "Opponent", "opponent", "Bot", "bot", "Bots", "bots",
    "Mob", "mob", "Mobs", "mobs", "Monster", "monster", "Monsters", "monsters",
    "Zombie", "zombie", "Zombies", "zombies", "Creature", "creature", "Animal", "animal", "Beast", "beast",
    "Villain", "villain", "Villian", "villian", "Boss", "boss", "MiniBoss", "miniboss",
    "Guard", "guard", "Guardian", "guardian", "Soldier", "soldier", "Warrior", "warrior",
    "Fighter", "fighter", "Target", "target", "Dummy", "dummy", "Dummies", "dummies",
    "Practice", "practice", "Training", "training", "Skeleton", "skeleton",
    "Orc", "orc", "Goblin", "goblin", "Troll", "troll", "Ogre", "ogre",
    "Demon", "demon", "Devil", "devil", "Ghost", "ghost", "Spirit", "spirit",
    "Vampire", "vampire", "Werewolf", "werewolf", "Dragon", "dragon", "Wyvern", "wyvern",
    "Gang", "gang", "Thug", "thug", "Bandit", "bandit", "Raider", "raider",
    "Pirate", "pirate", "Corsair", "corsair", "Agent", "agent", "Assassin", "assassin",
    "Mercenary", "mercenary", "Hunter", "hunter", "Robot", "robot", "Drone", "drone",
    "Android", "android", "Cyborg", "cyborg", "Automaton", "automaton",
    "Servant", "servant", "Minion", "minion", "Slave", "slave", "Pawn", "pawn",
    "AI", "ai", "A.I.", "Char", "char", "Character", "character", "Model", "model",
    "Event", "event", "Special", "special", "Holiday", "holiday", "Seasonal", "seasonal",
}

--// å‡½æ•¸ï¼šåµéŒ¯ NPC
local function DebugNPCDetection(character, reason)
    if not _G.DebugNPCs then return end
    print("[NPC DEBUG] åµæ¸¬åˆ°:", character.Name)
    print("  åŸå› :", reason)
end

--// å‡½æ•¸ï¼šåˆ¤æ–·æ˜¯å¦ç‚ºç©å®¶
local function IsPlayer(character)
    if not character or not character:IsA("Model") then return false end
    if character == LocalPlayer.Character then return true end
    local player = Players:GetPlayerFromCharacter(character)
    return player ~= nil
end

--// å‡½æ•¸ï¼šåˆ¤æ–·æ˜¯å¦ç‚º NPC
local function IsNPC(character)
    if not character or not character:IsA("Model") then return false end
    if IsPlayer(character) then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local head = character:FindFirstChild("Head")
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not head or not hrp or humanoid.Health <= 0 then return false end
    
    if _G.AggressiveNPCDetection then DebugNPCDetection(character, "æ¿€é€²æ¨¡å¼ - Humanoid çµæ§‹"); return true end
    
    local charName = character.Name:lower()
    for _, tag in pairs(NPCTags) do if charName:find(tag:lower(), 1, true) then DebugNPCDetection(character, "åç¨±åŒ…å«æ¨™ç±¤: " .. tag); return true end end
    
    local npcFolders = {"NPCs", "Enemies", "Bots", "Mobs", "Targets", "Enemy", "Hostile", "Monsters", "Zombies", "Creatures", "Characters", "Spawns", "EnemySpawns", "NPCSpawns", "Bosses", "Minions"}
    for _, folderName in pairs(npcFolders) do
        local folder = workspace:FindFirstChild(folderName)
        if folder and character:IsDescendantOf(folder) then DebugNPCDetection(character, "ä½æ–¼è³‡æ–™å¤¾: " .. folderName); return true end
    end
    
    local possibleNPCIndicators = {"NPC", "IsNPC", "IsEnemy", "Hostile", "Enemy", "IsBot", "IsMob", "IsMonster", "Team", "Faction"}
    for _, indicator in pairs(possibleNPCIndicators) do
        local value = character:FindFirstChild(indicator)
        if value then
            if value:IsA("BoolValue") and (indicator == "NPC" or indicator == "IsNPC" or indicator == "IsEnemy" or indicator == "Hostile") and value.Value == true then DebugNPCDetection(character, "BoolValue: " .. indicator); return true
            elseif value:IsA("StringValue") then
                local valLower = value.Value:lower()
                if valLower == "enemy" or valLower == "hostile" or valLower == "npc" or valLower == "bot" or valLower == "monster" or valLower == "mob" then DebugNPCDetection(character, "StringValue: " .. indicator); return true end
            elseif value:IsA("IntValue") and indicator == "Team" then DebugNPCDetection(character, "Team Value"); return true end
        end
    end
    
    local hasAIBehavior = false
    for _, child in pairs(character:GetChildren()) do
        local childName = child.Name:lower()
        if (child:IsA("Script") or child:IsA("LocalScript")) and (childName:find("ai") or childName:find("behavior") or childName:find("path") or childName:find("attack") or childName:find("patrol") or childName:find("combat")) then hasAIBehavior = true; break end
    end
    
    local tags = CollectionService:GetTags(character)
    for _, tag in pairs(tags) do
        local tagLower = tag:lower()
        for _, npcTag in pairs(NPCTags) do if tagLower:find(npcTag:lower(), 1, true) then DebugNPCDetection(character, "CollectionService æ¨™ç±¤: " .. tag); return true end end
    end
    
    local npcAbilities = {"Attack", "Damage", "Aggro", "Patrol", "Spawn", "Respawn", "AI", "BehaviorTree"}
    for _, ability in pairs(npcAbilities) do if character:FindFirstChild(ability) or character:FindFirstChild(ability .. "Script") then hasAIBehavior = true; break end end
    if hasAIBehavior then DebugNPCDetection(character, "åµæ¸¬åˆ° AI è¡Œç‚º"); return true end
    
    local namePatterns = {"^npc_", "^enemy_", "^bot_", "^mob_", "_npc$", "_enemy$", "_bot$"}
    for _, pattern in pairs(namePatterns) do if string.match(charName, pattern) then DebugNPCDetection(character, "åç¨±æ¨¡å¼: " .. pattern); return true end end
    
    DebugNPCDetection(character, "éç©å®¶ Humanoid (é€šç”¨çµæ§‹)"); return true
end

--// å‡½æ•¸ï¼šéè¿´æœç´¢ Workspace ä¸­çš„ NPC
local function FindNPCsInWorkspaceRecursive(parent)
    local foundNPCs = {}
    for _, child in pairs(parent:GetChildren()) do
        if child:IsA("Model") and IsNPC(child) then table.insert(foundNPCs, child) end
        if not child:IsA("BasePart") and not child:IsA("Decal") and not child:IsA("Texture") then
            local subNPCs = FindNPCsInWorkspaceRecursive(child)
            for _, npc in pairs(subNPCs) do table.insert(foundNPCs, npc) end
        end
    end
    return foundNPCs
end

--// å‡½æ•¸ï¼šæª¢æŸ¥ç©å®¶éšŠä¼
local function IsEnemyPlayer(player)
    if not _G.TeamCheck then return true end
    if not player or not LocalPlayer.Team or not player.Team then return true end
    return LocalPlayer.Team ~= player.Team
end

--// å‡½æ•¸ï¼šæª¢æŸ¥ NPC éšŠä¼
local function IsEnemyNPC(npcModel)
    if not _G.TeamCheckForNPCs then return true end
    local npcTeamValue = npcModel:FindFirstChild("Team")
    if npcTeamValue and npcTeamValue:IsA("StringValue") then
        local npcTeam = npcTeamValue.Value
        local localTeam = LocalPlayer.Team and LocalPlayer.Team.Name or ""
        if npcTeam and localTeam and npcTeam ~= localTeam then return true end
    end
    local isEnemy = npcModel:FindFirstChild("IsEnemy")
    if isEnemy and isEnemy:IsA("BoolValue") and isEnemy.Value == true then return true end
    return true
end

--// å‡½æ•¸ï¼šç²å–ç„æº–éƒ¨ä½
local function GetTargetPart(character)
    if _G.AimPart == "Head" then return character:FindFirstChild("Head")
    elseif _G.AimPart == "Torso" then return character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso") or character:FindFirstChild("HumanoidRootPart")
    elseif _G.AimPart == "Random" then
        local parts = {character:FindFirstChild("Head"), character:FindFirstChild("UpperTorso"), character:FindFirstChild("Torso"), character:FindFirstChild("HumanoidRootPart")}
        for _, part in pairs(parts) do if part then return part end end
    elseif _G.AimPart == "Both" then
        local head = character:FindFirstChild("Head")
        local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso") or character:FindFirstChild("HumanoidRootPart")
        if head and torso then return tick() % 1 > 0.5 and head or torso elseif head then return head elseif torso then return torso end
    end
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head")
end

--// å‡½æ•¸ï¼šæ›´æ–°å¿«å–
local function UpdateCaches()
    local currentTime = tick()
    if currentTime - LastCacheUpdate < CacheUpdateInterval then return end
    LastCacheUpdate = currentTime
    
    local tempNPCCache = {}
    local tempPlayerCache = {}
    local allModels = {}
    
    local wsChildren = workspace:GetChildren()
    for _, model in pairs(wsChildren) do if model:IsA("Model") and model ~= LocalPlayer.Character then table.insert(allModels, model) end end
    
    local npcFolders = {"NPCs", "Enemies", "Bots", "Mobs", "Targets", "Characters", "Spawns", "Monsters", "Zombies", "Enemy", "Hostile", "Bosses", "Minions", "Creatures"}
    for _, folderName in pairs(npcFolders) do
        local folder = workspace:FindFirstChild(folderName)
        if folder then
            local npcsInFolder = FindNPCsInWorkspaceRecursive(folder)
            for _, npc in pairs(npcsInFolder) do table.insert(allModels, npc) end
        end
    end
    
    if _G.AggressiveNPCDetection then
        local counter = 0
        local descendants = workspace:GetDescendants()
        for _, descendant in pairs(descendants) do
            if descendant:IsA("Model") and descendant ~= LocalPlayer.Character then
                table.insert(allModels, descendant)
                counter = counter + 1
                if counter % 150 == 0 then task.wait() end
            end
        end
    end
    
    local processCounter = 0
    for _, model in pairs(allModels) do
        processCounter = processCounter + 1
        if processCounter % 200 == 0 then task.wait() end
        local hrp = model:FindFirstChild("HumanoidRootPart")
        local humanoid = model:FindFirstChildOfClass("Humanoid")
        if hrp and humanoid and humanoid.Health > 0 then
            if IsPlayer(model) then tempPlayerCache[model] = {Model = model, HRP = hrp, Humanoid = humanoid, Player = Players:GetPlayerFromCharacter(model), IsNPC = false}
            elseif IsNPC(model) then tempNPCCache[model] = {Model = model, HRP = hrp, Humanoid = humanoid, IsNPC = true} end
        end
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local char = player.Character
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if hrp and humanoid and humanoid.Health > 0 then tempPlayerCache[char] = {Model = char, HRP = hrp, Humanoid = humanoid, Player = player, IsNPC = false} end
        end
    end
    
    NPCCache = tempNPCCache
    PlayerCache = tempPlayerCache
end

--// å‡½æ•¸ï¼šé©—è­‰ç•¶å‰ç›®æ¨™ (Sticky Aim)
local function ValidateCurrentTarget()
    if not CurrentTarget or not TargetPart then return false end
    local humanoid = CurrentTarget:FindFirstChildOfClass("Humanoid")
    local hrp = CurrentTarget:FindFirstChild("HumanoidRootPart")
    if not humanoid or humanoid.Health <= 0 or not hrp then return false end
    
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local targetPos = TargetPart.Position
    local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
    if not onScreen then return false end
    
    local screenPoint = Vector2.new(screenPos.X, screenPos.Y)
    local dist = (screenPoint - screenCenter).Magnitude
    if dist > _G.FOV then return false end
    
    if _G.VisibleCheck then
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastParams.IgnoreWater = true
        local origin = Camera.CFrame.Position
        local direction = (targetPos - origin).Unit * (targetPos - origin).Magnitude
        local ray = workspace:Raycast(origin, direction, raycastParams)
        if ray and not ray.Instance:IsDescendantOf(CurrentTarget) then return false end
    end
    return true
end

--// å‡½æ•¸ï¼šæœå°‹ç›®æ¨™
local function GetTarget()
    if not LocalPlayer.Character then TargetInRange = false; TargetPart = nil; return nil end
    UpdateCaches()
    
    if _G.StickyAim and CurrentTarget then
        if ValidateCurrentTarget() then TargetInRange = true; return CurrentTarget
        else CurrentTarget = nil; TargetPart = nil end
    end
    
    local bestScore = math.huge
    local closestPart = nil
    local closestTarget = nil
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local localChar = LocalPlayer.Character
    local localRoot = localChar:FindFirstChild("HumanoidRootPart")
    
    TargetInRange = false
    TargetPart = nil
    if not localRoot then return nil end
    
    local function ProcessTarget(data, isPlayer)
        local hrp = data.HRP
        local humanoid = data.Humanoid
        if hrp and humanoid and humanoid.Health > 0 then
            if isPlayer then if not IsEnemyPlayer(data.Player) then return end
            else if not IsEnemyNPC(data.Model) then return end end
            
            local targetPart = GetTargetPart(data.Model)
            if not targetPart then targetPart = hrp end
            local targetPos = targetPart.Position
            
            if hrp.Velocity.Magnitude > 1 and _G.Prediction > 0 then targetPos = targetPos + (hrp.Velocity * _G.Prediction) end
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
            
            if onScreen then
                local screenPoint = Vector2.new(screenPos.X, screenPos.Y)
                local distFromCenter = (screenPoint - screenCenter).Magnitude
                if distFromCenter <= _G.FOV then
                    local isVisible = true
                    if _G.VisibleCheck then
                        local raycastParams = RaycastParams.new()
                        raycastParams.FilterDescendantsInstances = {localChar, Camera}
                        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                        raycastParams.IgnoreWater = true
                        local origin = Camera.CFrame.Position
                        local direction = (targetPos - origin).Unit * (targetPos - origin).Magnitude
                        local ray = workspace:Raycast(origin, direction, raycastParams)
                        if ray and not ray.Instance:IsDescendantOf(data.Model) then isVisible = false end
                    end
                    
                    TargetInRange = true
                    if isVisible or not _G.VisibleCheck then
                        local currentScore = 0
                        if _G.TargetPriority == "Crosshair" then currentScore = distFromCenter
                        elseif _G.TargetPriority == "Distance" then currentScore = (targetPos - localRoot.Position).Magnitude
                        elseif _G.TargetPriority == "LowestHP" then currentScore = humanoid.Health
                        else currentScore = distFromCenter end
                        
                        if currentScore < bestScore then
                            bestScore = currentScore
                            closestPart = targetPart
                            closestTarget = data.Model
                        end
                    end
                end
            end
        end
    end
    
    if _G.TargetMode == "NPCs" or _G.TargetMode == "Both" then for _, data in pairs(NPCCache) do ProcessTarget(data, false) end end
    if _G.TargetMode == "Players" or _G.TargetMode == "Both" then for _, data in pairs(PlayerCache) do ProcessTarget(data, true) end end
    
    TargetPart = closestPart
    return closestTarget
end

--// æ›´æ–°ç›®æ¨™
task.spawn(function()
    while true do
        task.wait(_G.UpdateRate)
        if _G.SilentAim then CurrentTarget = GetTarget()
        else CurrentTarget = nil; TargetInRange = false; TargetPart = nil end
    end
end)

--// å‡½æ•¸ï¼šåˆ¤æ–·æ˜¯å¦å‘½ä¸­
local function ShouldHit()
    if _G.HitChance >= 100 then return true end
    if _G.HitChance <= 0 then return false end
    return math.random(1, 100) <= _G.HitChance
end

--// å‡½æ•¸ï¼šè¨ˆç®—å‘½ä¸­ç‡é¡¯ç¤º
local function CalculateHitChanceDisplay()
    if not CurrentTarget or not TargetPart then return 0 end
    local baseChance = _G.HitChance
    local distanceFactor = 1.0
    local fovFactor = 1.0
    
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local distance = (TargetPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
        if distance < 50 then distanceFactor = 1.1 elseif distance > 200 then distanceFactor = 0.8 end
    end
    
    if _G.FOV < 100 then fovFactor = 1.15 elseif _G.FOV > 250 then fovFactor = 0.9 end
    local finalChance = math.clamp((baseChance * distanceFactor * fovFactor) + math.random(-5, 5), 1, 100)
    return math.floor(finalChance)
end

--// å‡½æ•¸ï¼šæ›´æ–°ç›®æ¨™è³‡è¨Š
local function UpdateTargetInfo()
    if not _G.ShowTarget or not TargetInfo or not _G.SilentAim then
        TargetInfo.Visible = false; TargetInfo.Text = ""; return
    end
    
    local shouldShowHitChance = _G.ShowHitChance and _G.HitChance > 0
    if CurrentTarget and TargetPart then
        local screenPos, onScreen = Camera:WorldToViewportPoint(TargetPart.Position)
        if onScreen then
            TargetInfo.Visible = true
            TargetInfo.Position = Vector2.new(screenPos.X, screenPos.Y + 20)
            local infoLines = {}
            
            if _G.ShowTargetName then
                local targetName = CurrentTarget.Name
                local targetType = "NPC"
                for _, data in pairs(PlayerCache) do
                    if data.Model == CurrentTarget then targetType = "ç©å®¶"; targetName = data.Player.Name; break end
                end
                if _G.ShowTargetType then table.insert(infoLines, string.format("[%s] %s", targetType, targetName))
                else table.insert(infoLines, targetName) end
            end
            
            if _G.ShowTargetHP then
                local humanoid = CurrentTarget:FindFirstChildOfClass("Humanoid")
                if humanoid then table.insert(infoLines, string.format("HP: %.0f/%.0f", humanoid.Health, humanoid.MaxHealth)) end
            end
            
            if _G.ShowTargetDistance then
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local distance = string.format("%.1f", (TargetPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude)
                    table.insert(infoLines, string.format("è·é›¢: %s studs", distance))
                end
            end
            
            if shouldShowHitChance then table.insert(infoLines, string.format("æ©Ÿç‡: %d%%", CalculateHitChanceDisplay())) end
            
            TargetInfo.Text = #infoLines > 0 and table.concat(infoLines, "\n") or "å·²é–å®šç›®æ¨™"
        else TargetInfo.Visible = false; TargetInfo.Text = "" end
    else TargetInfo.Visible = false; TargetInfo.Text = "" end
end

--// HOOKS
if not oldNamecall then
    oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        if not _G.SilentAim or not TargetPart or not CurrentTarget then return oldNamecall(self, ...) end
        
        local method = getnamecallmethod()
        local args = {...}
        
        if (method == "FireServer" or method == "InvokeServer") and typeof(self) == "Instance" then
            local selfName = self.Name:lower()
            if string.find(selfName, "fire") or string.find(selfName, "hit") or string.find(selfName, "attack") or string.find(selfName, "damage") then
                if not ShouldHit() then return oldNamecall(self, ...) end
                
                local newArgs = {}
                local modified = false
                
                for i, arg in pairs(args) do
                    if typeof(arg) == "Vector3" then newArgs[i] = TargetPart.Position; modified = true
                    elseif typeof(arg) == "CFrame" then newArgs[i] = CFrame.new(TargetPart.Position); modified = true
                    elseif typeof(arg) == "Ray" then newArgs[i] = Ray.new(arg.Origin, (TargetPart.Position - arg.Origin).Unit * 100); modified = true
                    else newArgs[i] = arg end
                end
        
                if modified then return oldNamecall(self, unpack(newArgs)) end
            end
        end
        
        if method == "Raycast" and self == workspace then
            local origin = args[1]
            local direction = args[2]
            if origin and TargetPart then
                if not ShouldHit() then return oldNamecall(self, ...) end
                local newDir = (TargetPart.Position - origin).Unit * direction.Magnitude
                return oldNamecall(self, origin, newDir, args[3], args[4])
            end
        end
        return oldNamecall(self, ...)
    end)
end

if not oldIndex then
    oldIndex = hookmetamethod(game, "__index", function(self, key)
        if self == Mouse and _G.SilentAim and TargetPart then
            local keyLower = string.lower(key)
            if keyLower == "hit" then
                if not ShouldHit() then return oldIndex(self, key) end
                return CFrame.new(TargetPart.Position)
            elseif keyLower == "target" then return TargetPart end
        end
        return oldIndex(self, key)
    end)
end

--// æ›´æ–°è¿´åœˆ (è¦–è¦º - å·²è§£é™¤å¹€ç‡é™åˆ¶)
RunService.RenderStepped:Connect(function()
    Circle.Visible = _G.SilentAim
    if _G.SilentAim then
        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        Circle.Position = screenCenter
        Circle.Radius = _G.FOV
        
        if CurrentTarget then
            local isPlayerTarget = false
            for _, data in pairs(PlayerCache) do if data.Model == CurrentTarget then isPlayerTarget = true; break end end
            Circle.Color = isPlayerTarget and Color3.fromRGB(0, 150, 255) or Color3.fromRGB(0, 255, 0)
        else
            Circle.Color = TargetInRange and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 50, 0)
        end
    else Circle.Visible = false end
    
    UpdateTargetInfo()
    UpdateHighlight()
end)

--// ==================================================
--// MANO GUSTAVO UI LIBRARY 
--// ==================================================

local Library = loadstring(game:HttpGet(
    "https://raw.githubusercontent.com/Mano-Gustavo/Mano-Gustavo-Library/refs/heads/main/library.lua"
))()

local Window = Library:CreateWindow({
    Title = "ğŸ¯ éœé»˜ç„æº– v3.1 (å…¨è§£é–çµ²æ»‘ç‰ˆ)",
    Author = "Silent Aim NPC",
    Keybind = Enum.KeyCode.RightControl
})

--// å‰µå»º 8 å€‹å®Œæ•´åˆ†é 
local TabMain = Window:CreateTab("ä¸»è¦è¨­å®š")
local TabPriority = Window:CreateTab("å„ªå…ˆç´šåˆ¥")
local TabConfig = Window:CreateTab("è©³ç´°è¨­å®š")
local TabAim = Window:CreateTab("ç„æº–è¦–è¦º")
local TabTeam = Window:CreateTab("éšŠä¼åˆ¤å®š")
local TabExtra = Window:CreateTab("é¡å¤–åŠŸèƒ½")
local TabNPC = Window:CreateTab("NPC æ§åˆ¶")
local TabInfo = Window:CreateTab("è³‡è¨Šèˆ‡ç‹€æ…‹")

--// 1. ä¸»è¦è¨­å®š (TabMain)
TabMain:CreateLabel("=== ä¸»è¦æ§åˆ¶é … ===")
TabMain:CreateToggle("å•Ÿå‹•éœé»˜ç„æº– (Silent Aim)", function(Value)
    _G.SilentAim = Value
    if Value then
        LastCacheUpdate = 0; UpdateCaches()
        Library:Notification({Title = "ğŸ¯ éœé»˜ç„æº–", Text = "å·²å•Ÿç”¨", Duration = 1.5, Type = "Success"})
    else
        if TargetHighlight then TargetHighlight:Destroy(); TargetHighlight = nil end
        Library:Notification({Title = "ğŸ¯ éœé»˜ç„æº–", Text = "å·²åœç”¨", Duration = 1.5, Type = "Error"})
    end
end, false)

TabMain:CreateSlider("ç¯„åœå¤§å° (FOV)", 50, 300, 150, function(Value) _G.FOV = math.floor(Value); Circle.Radius = _G.FOV end)
TabMain:CreateSlider("é åˆ¤å¼·åº¦ (PrediÃ§Ã£o)", 0, 0.5, 0, function(Value) _G.Prediction = tonumber(string.format("%.3f", Value)) end) -- é è¨­æ”¹ç‚º 0
TabMain:CreateSlider("å‘½ä¸­æ©Ÿç‡ (Hit Chance)", 0, 100, 100, function(Value) _G.HitChance = math.floor(Value) end)
TabMain:CreateSlider("æ›´æ–°é »ç‡ (Taxa de AtualizaÃ§Ã£o)", 0, 0.5, 0.01, function(Value) _G.UpdateRate = tonumber(string.format("%.3f", Value)) end) -- é è¨­æ”¹ç‚º 0.01

--// 2. å„ªå…ˆç´šåˆ¥ (TabPriority)
TabPriority:CreateLabel("=== ç›®æ¨™é–å®šé‚è¼¯ ===")
TabPriority:CreateLabel("è¨­å®šè…³æœ¬å¦‚ä½•é¸æ“‡å„ªå…ˆç›®æ¨™ï¼š")

TabPriority:CreateDropdown("å„ªå…ˆæ¨¡å¼", {"Crosshair", "Distance", "LowestHP"}, function(Value)
    _G.TargetPriority = Value
    CurrentTarget = nil 
    Library:Notification({Title = "æ¨¡å¼å·²è®Šæ›´", Text = "ç•¶å‰å„ªå…ˆ: " .. Value, Duration = 2})
end)

TabPriority:CreateToggle("é»æ€§é–å®š (Sticky Aim)", function(Value)
    _G.StickyAim = Value
end, true)

TabPriority:CreateLabel("----------------")
TabPriority:CreateLabel("â€¢ Crosshair (æº–æ˜Ÿ): é–å®šæœ€é è¿‘ç•«é¢ä¸­å¿ƒçš„ç›®æ¨™")
TabPriority:CreateLabel("â€¢ Distance (è·é›¢): é–å®šéŠæˆ²å…§è·é›¢ä½ æœ€è¿‘çš„ç›®æ¨™")
TabPriority:CreateLabel("â€¢ LowestHP (æœ€ä½è¡€é‡): é–å®šè¡€é‡æœ€å°‘çš„ç›®æ¨™")
TabPriority:CreateLabel("â€¢ é»æ€§é–å®š: ç›®æ¨™æ­»äº¡å‰ä¸æœƒéš¨æ„åˆ‡æ›ï¼Œé˜²æ­¢é¡é ­äº‚æŠ–")

--// 3. è©³ç´°è¨­å®š (TabConfig)
TabConfig:CreateLabel("=== ä¸€èˆ¬è¨­å®š ===")
TabConfig:CreateDropdown("ç„æº–å°è±¡", {"Players", "NPCs", "Both"}, function(Value) _G.TargetMode = Value end) -- é è¨­æ”¹ç‚º Players
TabConfig:CreateDropdown("èº«é«”éƒ¨ä½", {"Head", "Torso", "Both", "Random"}, function(Value) _G.AimPart = Value end)
TabConfig:CreateToggle("ç‰†å£æª¢æŸ¥ (Wall Check)", function(Value) _G.VisibleCheck = Value end, true)
TabConfig:CreateToggle("å­å½ˆå‚³é€ (Bullet Teleport)", function(Value) _G.BulletTeleport = Value end, false)
TabConfig:CreateToggle("é¡¯ç¤ºç›®æ¨™å¤–æ¡†", function(Value) _G.ShowTarget = Value end, true)

--// 4. ç„æº–è¦–è¦º (TabAim)
TabAim:CreateLabel("=== ç„æº–é¡è¨­å®š ===")
TabAim:CreateLabel("é ­éƒ¨(Head): è‡´å‘½å‚·å®³ | èº«é«”(Torso): æ™®é€šå‚·å®³")
TabAim:CreateColorPicker("FOV åœ“åœˆé¡è‰²", Color3.fromRGB(0, 255, 0), function(Color) Circle.Color = Color end)

--// 5. éšŠä¼åˆ¤å®š (TabTeam)
TabTeam:CreateLabel("=== éšŠä¼è¨­å®š ===")
TabTeam:CreateToggle("æª¢æŸ¥éšŠå‹ (ç©å®¶)", function(Value) _G.TeamCheck = Value end, true)
TabTeam:CreateToggle("æª¢æŸ¥éšŠå‹ (NPC)", function(Value) _G.TeamCheckForNPCs = Value end, false)

--// 6. é¡å¤–åŠŸèƒ½ (TabExtra)
TabExtra:CreateLabel("=== é¡å¤–é¡¯ç¤ºè¨­å®š ===")
TabExtra:CreateToggle("ç›®æ¨™é«˜äº®é¡¯ç¤º (Highlight)", function(Value) _G.HighlightTarget = Value end, false)
TabExtra:CreateColorPicker("NPC é«˜äº®é¡è‰²", Color3.fromRGB(255, 50, 50), function(Color) end)
TabExtra:CreateColorPicker("ç©å®¶é«˜äº®é¡è‰²", Color3.fromRGB(50, 150, 255), function(Color) end)
TabExtra:CreateTextBox("å¿«å–åˆ·æ–°é–“éš” (ç§’)", "0.5", function(Text) local num = tonumber(Text); if num and num >= 0 then CacheUpdateInterval = num end end)

TabExtra:CreateLabel("=== å¯¦ç”¨åŠŸèƒ½ ===")
-- [æ–°å¢] ç¬é–“äº’å‹•é–‹é—œç¶å®š
TabExtra:CreateToggle("ç¬é–“äº’å‹• (Instant Interact)", function(Value) 
    _G.InstantInteract = Value 
end, false)

--// 7. NPC æ§åˆ¶ (TabNPC)
TabNPC:CreateLabel("=== NPC è¨­å®š ===")
TabNPC:CreateToggle("æ¿€é€²åµæ¸¬æ¨¡å¼ (é˜²å»¶é²)", function(Value)
    _G.AggressiveNPCDetection = Value
    LastCacheUpdate = 0; UpdateCaches()
    if Value then Library:Notification({Title = "âš ï¸ æ¿€é€²æ¨¡å¼", Text = "å·²å•Ÿç”¨ - é˜²å»¶é²æ©Ÿåˆ¶é‹ä½œä¸­", Duration = 2, Type = "Warning"}) end
end, false)
TabNPC:CreateToggle("åœ¨æ§åˆ¶å° Debug NPCs", function(Value) _G.DebugNPCs = Value end, false)
TabNPC:CreateButton("å¼·åˆ¶æ›´æ–° NPC å¿«å–", function() LastCacheUpdate = 0; UpdateCaches() end)
TabNPC:CreateButton("åˆ—å‡ºåµæ¸¬åˆ°çš„ NPC", function()
    local npcCount = 0; for _ in pairs(NPCCache) do npcCount = npcCount + 1 end
    Library:Notification({Title = "ğŸ“Š åµæ¸¬å ±å‘Š", Text = string.format("å·²é–å®š NPC æ•¸é‡: %d", npcCount), Duration = 2})
end)

--// 8. è³‡è¨Šèˆ‡ç‹€æ…‹ (TabInfo)
TabInfo:CreateLabel("=== è³‡è¨Šä»‹é¢æ§åˆ¶ ===")
TabInfo:CreateToggle("é¡¯ç¤º åç¨±/é¡å‹", function(Value) _G.ShowTargetName = Value; if _G.SilentAim then UpdateTargetInfo() end end, true)
TabInfo:CreateToggle("é¡¯ç¤º è¡€é‡ (HP)", function(Value) _G.ShowTargetHP = Value; if _G.SilentAim then UpdateTargetInfo() end end, true)
TabInfo:CreateToggle("é¡¯ç¤º è·é›¢", function(Value) _G.ShowTargetDistance = Value; if _G.SilentAim then UpdateTargetInfo() end end, true)
TabInfo:CreateToggle("é¡¯ç¤º å‘½ä¸­æ©Ÿç‡", function(Value) _G.ShowHitChance = Value; if _G.SilentAim then UpdateTargetInfo() end end, true)
TabInfo:CreateLabel("ç‰ˆæœ¬è³‡è¨Šï¼š3.1 (å…¨è§£é–çµ²æ»‘ç‰ˆ + ç¬é–“äº’å‹•)")
TabInfo:CreateLabel("âœ… å°ˆç‚º The Border æœ€ä½³åŒ–")
TabInfo:CreateButton("æ¸…é™¤ç•«é¢ UI", function() CleanupUIOnly() end)

Library:Notification({
    Title = "ğŸ¯ The Border å°ˆç”¨ç‰ˆ",
    Text = "å¹€ç‡é™åˆ¶å·²è§£é™¤ï¼Œé åˆ¤èˆ‡åˆ·æ–°å·²æœ€ä½³åŒ–ï¼",
    Duration = 4,
    Type = "Success"
})

--// é›¢é–‹éŠæˆ²æ™‚è‡ªå‹•æ¸…ç†
game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then CleanupUIOnly() end
end)
